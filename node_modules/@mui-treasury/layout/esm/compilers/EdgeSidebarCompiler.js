function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import HeaderEffect from '../effects/Header';
import { combineBreakpoints, pickNearestBreakpoint } from '../utils';
import { isPermanentSidebarConfig, isPersistentSidebarConfig, isTemporarySidebarConfig } from '../utils/sidebarChecker';
import createEdgeSidebarModel from '../models/Sidebar/Edge/EdgeSidebarModel';
export default (function (state, edgeSidebar, header) {
  return {
    getResultStyle: function getResultStyle(sidebarId) {
      var result = {
        persistent: {},
        permanent: {},
        temporary: {}
      };
      var sidebarConfigMap = edgeSidebar.configMapById[sidebarId];
      if (!sidebarConfigMap) return result;
      var configMap = sidebarConfigMap;
      var breakpoints = combineBreakpoints(configMap, header);
      breakpoints.forEach(function (bp) {
        var config = pickNearestBreakpoint(configMap, bp);

        if (config) {
          var headerEffect = HeaderEffect(pickNearestBreakpoint(header, bp));

          if (isPersistentSidebarConfig(config) && headerEffect) {
            result.persistent[bp] = _extends(_extends({}, createEdgeSidebarModel(config, state)), headerEffect.getEdgeSidebarZIndex(sidebarId));
          } else if (isPermanentSidebarConfig(config) && headerEffect) {
            result.permanent[bp] = _extends(_extends({}, createEdgeSidebarModel(config, state)), headerEffect.getEdgeSidebarZIndex(sidebarId));
          } else if (isTemporarySidebarConfig(config)) {
            result.temporary[bp] = {
              width: config.width
            };
          }
        }
      });
      return result;
    }
  };
});